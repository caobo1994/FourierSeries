\documentclass[12pt, titlepage]{article}
\usepackage{xspace}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{mathtools}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}

\input{../../Comments}
\input{../../Common}


\begin{document}

\title{A Fourier Series Library: Unit Verification and Validation Plan for FSL} 
\author{Bo Cao}
\date{\today}
	
\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Oct. 28, 2019  & 1.0 & First draft.\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

~\newpage

\tableofcontents

\newpage

\section{Symbols, Abbreviations and Acronyms}

Some symbols, abbreviations and acronyms are defined in the Software Requirement and Specification (SRS) document \footnote{This document is available at \url{https://github.com/caobo1994/FourierSeries/blob/master/docs/SRS/SRS.pdf}.}. For simplicity and maintainability, they are not redefined here. Readers shall refer to the SRS documents when a certain item is not defined here.

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  T & Test\\
  \bottomrule
\end{tabular}\\


\newpage

\pagenumbering{arabic}

This document provides an overview of the Verification and Validation (VnV) plan for the Fourier Series Library (FSL). It lays out the purpose, methods, and test cases for the VnV procedure. 

\section{General Information}

\subsection{Purpose}

The library to be tested is called the Fourier Series Library (FSL). This library performs a set of computations, transformations, and/or input/output at the request of the library user.

\subsection{Scope}

The intended objective of the VnV procedure is to verify that this library has generally met the requirements described in the SRS document. These requirements include the functional requirements (FRs) and the non-functional requirements (NFRs).

Note that if a small part of the NFRs has not been met, the library is still acceptable when the not-met NFRs' impact has been analyzed and deemed non-essential.

The transformation from a function to its CFS involves numerical integration, and the division operation of CFS's contain solving of linear equations. We plan to use existing libraries for these tasks. Instead of test these libraries, we will trust them on the ground of their developers' and other users' through testing.

\section{Plan}
	
\subsection{Verification and Validation Team}

The author of this library, Bo Cao, will do all the Unit VnV, including the design, coding and execution of the Automated Testing.


\subsection{Automated Testing and Verification Tools}

We have decided that this library will be implemented in \li{C++}.

The unit test library we choose is \li{Catch2}\footnote{Available at \url{https://github.com/catchorg/Catch2}}. This library is designed for simple unit testing in both \li{C} and \li{C++}. We choose this library because it is light-weight, thus easy to install and use. These two properties are especially helpful in our situation, since I expect that most of the other collaborators have little knowledge in C++ and unit testing.

The static analysis will be done by \li{cpplint}. This is a classic \li{C++} program static analysis tool. It is maintain by Google for checking a \li{C++} program's consistency with Google's \li{C++} code style guidance. This tool and guidance can be found at \url{https://github.com/google/styleguide}.

The code coverage of the designed unit test cases will be tested by \li{gcov}. This is the standard code coverage tool that is assisted by the GNU program/library family's \li{C++} compiler, \li{g++}. An detailed introduction can be found in \url{https://gcc.gnu.org/onlinedocs/gcc/Gcov.html}.

The (pseudo-)oracles for unit testing come from manual computation and/or the results computed by MATLAB's Fourier Transformation library.

\subsection{Non-Testing Based Verification}

We will have a code inspection and walkthrough of some functions in this library, if they are deemed too complex. This test will be assisted by the result of \li{cpplint}. 

\section{Unit Test Description}

The unit test cases of this library will be based on the system test cases of this library, with the following additions and modifications.
\subsection{Tests for Functional Requirements}
Due to the nature of the library, the test of most functions are defined in the System VnV. We will not elaborate on these defined functions.

We should also notice that these three functions must be tested in order, and these functions must be tested before other functions: \licpp{Subtraction}, \li{Amplitude}, \li{ToleratedEquality}.

\subsubsection{Module 1: Linear Solver}
\begin{enumerate}
	\item Test of \licpp{LinSolve}:\\
	
	Type: Automatic\\
	Initial State: Loaded library\\
	Input: $m=2, M=\begin{bsmallmatrix}
	1 & 1\\0 & 1
	\end{bsmallmatrix}, b=\begin{bsmallmatrix}
	3\\1
	\end{bsmallmatrix}$
	Output: $a$, whose oracle is$\begin{bsmallmatrix}
	2\\1
	\end{bsmallmatrix}$
	Test Case Derivation: output shall match oracle exactly.
	How the test will be performed: Unit Test will call the function with the input, and compare the output with the oracle. 
\end{enumerate}

\subsubsection{Module 2: Integral}
\begin{enumerate}
	\item Test of \licpp{Integral}:\\
	
	Type: Automatic\\
	Initial State: Loaded library\\
	Input: $f=t\rightarrow t, a=0, b=1$
	Output: $\textit{res}$, whose oracle is 0.5.
	Test Case Derivation: difference between oracle and output shall be smaller than $\epsilon=10^{-6}$.
	How the test will be performed: Unit Test will call the function with the input, and compare the output with the oracle (called Compare later.) 
\end{enumerate}

\subsubsection{Module 3: Conversion}
The unit test is the same as the system test, and we give a table describing which system test is for which function.
\begin{table}[h]
	\centering
	\begin{tabular}{c c}
		\hline
		Test name & Function\\
		\hline
		Test of conversion from other data format&\licpp{ConvertFrom}\\
		Test of conversion to other data format&\licpp{ConvertTo}\\
		\hline
	\end{tabular}
\end{table}
\subsubsection{Module 4: Transformation}
The unit test is the same as the system test, and we give a table describing which system test is for which function.
\begin{table}[h]
	\centering
	\begin{tabular}{c c}
		\hline
		Test name & Function\\
		\hline
		Test of coefficient (even function)&\licpp{Transform}\\
		Test of coefficient (odd function)&\\
		Test of approximated function value&\licpp{FunctionValue}\\
		\hline
	\end{tabular}
\end{table}
\subsubsection{Module 5: Basic Operation}
The unit test is the same as the system test except for the \li{CFSMatch} function, and we give a table describing which system test is for which function.

\begin{table}[h]
	\centering
	\begin{tabular}{c c}
		\hline
		Test name & Function\\
		\hline
		Test of addition&\licpp{Addition}\\
		Test of subtraction&\licpp{Subtraction}\\
		Test of multiplication
		&\licpp{Multiplication}\\
		Test of division&\licpp{Division}\\
		Test of amplitude&\licpp{Amplitude}\\
		\hline
	\end{tabular}
\end{table}

The test template for the \licpp{CFSMatch} function is
\begin{enumerate}
	\item Test of \licpp{CFSMatch}:\\
	
	Type: Automatic\\
	Initial State: Loaded library\\
	Input: $CFSf=[n=2, \omega=1.0, A=\{0, 0, 0\}, B=\{0, 0\}]$, $CFSg=[n=a, \omega=b, A=\{...\}, B=\{...\}]$. The length of $A$ and $B$ in $CFSg$ shall be  decided in accordance with $n$, and the values of elements in $A$ and $B$ shall all be $0$.\\
	Output: $\textit{res}$, whose oracle is $c$.\\
	Test Case Derivation: output shall fully match the oracle.\\
	How the test will be performed: Unit Test will call the function with the input, and compare the output with the oracle. 
\end{enumerate}
We generate test cases from this template by doing the following replacements.
\begin{table}[h]
	\centering
	\begin{tabular}{c|c c c}
		\hline
		Case No.&$a$&$b$&$c$\\
		\hline
		1&2&1.0&\licpp{true}\\
		2&2&0.5&\licpp{false}\\
		3&1&1.0&\licpp{false}\\
		4&1&0.5&\licpp{false}\\
		\hline
	\end{tabular}
\end{table}

\textbf{Note: For the sake of clarity, we can also choose other sets of data for the test of multiplication. For each set of data described below, users can generate a test case by replacing the data in the original test case with the data in each set.}
\begin{table}[h]
	\centering
	\begin{tabular}{c|c c c c c c}
		\hline
		Case No.& A of CFSf&B of CFSf&A of CFSg&B of CFSg& A of CFSres & B of CFSres\\
		\hline
		1&$\{1, 0, 0\}$&$\{0, 0\}$&$\{1, 0, 0\}$&$\{0, 0\}$&$\{0.5, 0, 0.5\}$&$\{0, 0\}$\\
		2&$\{1, 0, 0\}$&$\{0, 0\}$&$\{0, 0, 0\}$&$\{0, 1\}$&$\{0, 0, 0\}$&$\{0.5, 0\}$\\		
		3&$\{0, 1, 0\}$&$\{0, 0\}$&$\{0, 0, 0\}$&$\{1, 0\}$&$\{0, 0, 0\}$&$\{-0.5, 0\}$\\		
		4&$\{0, 0, 0\}$&$\{1, 0\}$&$\{0, 0, 0\}$&$\{1, 0\}$&$\{0.5, 0, -0.5\}$&$\{0, 0\}$\\
	\end{tabular}
\end{table}
\subsubsection{Module 6: Advanced Operations}
The unit test is the same as the system test except for the \licpp{Power} function, and we give a table describing which system test is for which function.

\begin{table}[h]
	\centering
	\begin{tabular}{c c}
		\hline
		Test name & Function\\
		\hline
		Test of tolerated equality function \li{TolEq} (\li{True} result)&\licpp{ToleratedEquality}\\
		Test of tolerated equality function \li{TolEq} (\li{False} result)&\\
		Test of function of CFS
		&\licpp{Function}\\
		\hline
	\end{tabular}
\end{table}
Note: $e^\textit{CFS}$ is \licpp{Function(CFS, expDeriv)}.

The test case template for the \licpp{Power} function is  
\begin{enumerate}
	\item Test of \li{Power}:\\
	Input: $\textit{CFSf}=[n=3, \omega=1.0, A=a, B=b]$, $m=3$\\
	Output: \licpp{Power(CFSf, m)}, whose oracle is $\textit{CFSstd}=[n=3, \omega=1.0, A=a_o, B=b_o]$\\
	Test Case Derivation: \licpp{ToleratedEquality(Power(CFSf, m), CFSstd, err)}, which should be \licpp{true} when $\textit{err}=10^{-6}$. 
\end{enumerate}
We generate two test cases from this template with the following sets of values.
\begin{table}[h]
	\centering
	\begin{tabular}{c|c c c c}
	\hline
	Case No.&$A$&$B$&$A_o$&$B_o$\\
	\hline
	1&$\{0, 1, 0, 0\}$&$\{0, 0, 0\}$&$\{0, 0.75, 0, 0.25\}$&$\{0, 0, 0\}$\\
	2&$\{0, 0, 0, 0\}$&$\{1, 0, 0\}$&$\{0, 0, 0, 0\}$&$\{0,75, 0, -0.25, 0\}$\\
	\hline	
	\end{tabular}
\end{table}

\subsection{Tests for Nonfunctional Requirements}

Same as the System VnV.

\subsection{Traceability Between Test Cases and Modules}
Since the test cases are already grouped in accordance with their module, this section is not necessary.



\bibliographystyle{plainnat}

\bibliography{SRS}

\end{document}