\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}

\input{../Common}
\input{../Comments}

\newcommand{\singlefigure}[5]{
	\begin{subfigure}[b]{#1\textwidth}
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{#4}
		\label{Fig:#5}
	\end{subfigure}
}

\newcommand{\func}[1]{\singlefigure{0.4}{}{#1.png}{Function \licpp{#1}}{#1}}

\newcommand{\twohalvesfigure}[6]{
	\singlefigure{0.4}{}{#1}{#2}{#3}
	\singlefigure{0.4}{}{#4}{#5}{#6}
}
\newcommand{\twofigure}[8]{
	\begin{figure}[H]
		\centering
		\twohalvesfigure{#1}{#2}{#3}{#4}{#5}{#6}
		\caption{#7}
		\label{Fig:#8}
	\end{figure}
}

\begin{document}

\title{System and Unit Test Report: Fourier Series Library} 
\author{Bo Cao}
\date{\today}
	
\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Dec. 17, 2019 & 1.0 & First and final draft.\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  T & Test\\
  \bottomrule
\end{tabular}\\

\wss{symbols, abbreviations or acronyms -- you can reference the SRS tables if needed}

\newpage

\tableofcontents

\listoftables %if appropriate

\listoffigures %if appropriate

\newpage

\pagenumbering{arabic}

This document introduces the result of the Unit VnV procedure.

\section{Functional Requirements Evaluation}\label{Sc:FR}
All the functional requirements have been met, except for the division function.
\section{Nonfunctional Requirements Evaluation}\label{Sc:NFR}
Generally, all the requirements have been met.
\subsection{Usability}\label{Sc:Use}
During implementation, we find out that several functions' names are too long to use. For the sake of compatibility, we will introduce  shorter function names in parallel. These functions with shorter names are essentially wrappers to the original ones, and the structures of these functions are too simple, so we do not test them.

We show a list of old function names versus new function names.
\begin{table}[h]
	\centering
	\begin{tabular}{c c}
		\hline
		Old Function Name& New Function Name\\
		\hline
		\licpp{Addition}&\licpp{Add}\\
		\licpp{Subtraction}&\licpp{Sub}\\
		\licpp{Multiplication}&\licpp{Mul}\\
		\licpp{Division}&\licpp{Div}\\
		\licpp{Amplitude}&\licpp{Amp}\\
		\licpp{ToleratedEquality}&\licpp{TolEq}\\
		\hline
	\end{tabular}
\end{table}		
\subsection{Performance}\label{Sc:Perf}
We have done performance tests on three functions, \li{Amplitude}, \li{Multiplication}, and \li{TransformTo}. Each of these tests represents tests on functions with one kind of speed rule. The tests on other functions will be done in the future.

We give the plots for these functions. The extrapolation will be done in the future, since these plots are already convincing.
\begin{figure}[h]
	\centering
%	\begin{subfigure}[b]{0.5\textwidth}
%	\centering
%	\includegraphics[width=\textwidth]{Amplitude.png}
%	\caption{Function \licpp{Amplitude}}
%	\label{Fig:Amplitude}
%\end{subfigure}
	\func{Amplitude}
	\func{Multiplication}
	\func{TransformTo}
	\caption{Selected functions: Data Size versus Exectution time}
\end{figure}
In these figures, \autoref{Fig:Amplitude} and \autoref{Fig:TransformTo} shows that the execution time of functions \li{Amplitude} and \li{TransformTo} is generally proportional to the data size, while \autoref{Fig:Multiplication} shows that the execution time of function \li{Multiplication} is generally proportional to the square of the data size. These speed rules are consistent with what we expect.
\subsection{Portability and Install-ability}
The unit testing has been performed on Ubuntu 18.04.3 and Mac OS X 10.11, with compilers gcc-7 and clang++-6.0. Based on the compatibility reports by the developers and users of these operating systems and compilers, we have confidence that this library should work on all *nix-based systems, with a C++ compiler supporting C++-17.

We also tested the installation and configuration of this library. We found out that the installation is a simple copy of all the header files, and the configuration only involves designating the location of these library during the user's building of their own programs. However, we found out that users have to include these headers one-by-one, and we think that an all-inclusive header might facilitate this process. We have implemented headers for each module, as well as an all-inclusive header.2

\section{Unit Testing}
The Unit Testing has been done with Catch2 in accordance with Unit VnV. All tests except these for function \licpp{Division} succeeds. We will fix this function in the future.

\section{Changes Due to Testing}
Most changes are grammar related. We list those changes that are not trivial.

\begin{enumerate}
	\item
	\begin{itemize}
		\item Function: \licpp{CFSData::setn}
		\item Problem: Old data still exists after resizing the sequences. 
		\item Solution: \licpp{std::fill(A.begin(), A.end(), 0)},\\ \licpp{std::fill(B.begin(), B.end(), 0)}
	\end{itemize}
	\item 
	\begin{itemize}
		\item Function: \licpp{Addition} and \li{Subtraction}
		\item Problem: Last element not computed. 
		\item Solution: \licpp{for(size_t i = 0; i<n; ++i)}\licpp{<} $\rightarrow$ \licpp{<=}
	\end{itemize}
	\item
	\begin{itemize}
		\item Function: \licpp{Multiplication}
		\item Problem: Computation part wrong, unable to debug. 
		\item Solution: Computation part changed from the mathematical expression in SRS to a more basic function. Easy to implement now.
	\end{itemize}
\end{enumerate}

\section{Automated Testing}
Test can now be done via the \li{r} script file. This file contains commands for building the test program based on the test case, as well as executing the test program.
%\section{Trace to Requirements}
	
%\section{Trace to Modules}		

\section{Code Coverage Metrics}
The following lines of code are reported by \li{gcov} as being not covered.
\begin{enumerate}
	\item All the exception-throwing lines in \li{CFSData.hpp}
	\item All the \licpp{return false;} in \li{CFSMatch.hpp}. This is strange, since there are test cases that requires the function to return \licpp{false}, and these test cases are success. Later, we change the compiler flag from "-O3" meaning maximum optimization to "-O0" meaning no optimization, and these codes are shown covered in our test. We thus conclude that these codes are optimized when "-O3" flag is used.
\end{enumerate}
These codes are examined manually by us to be right, and we will produces test cases for these un-covered codes in the future.

\bibliographystyle{plainnat}

\bibliography{../../../ReferenceMaterial/References}

\end{document}