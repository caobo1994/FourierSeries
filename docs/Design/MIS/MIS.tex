\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}
\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{makecell}
\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}
\input{../../Common}
\input{../../Comments}
\newcommand{\func}[1]{\\\hline\li{#1}}
\newcommand{\float}{\text{FLOAT}}
\newcommand{\seq}[2]{seq(\li{#1}, $#2$)}
\newcommand{\seqo}[1]{seq(\li{#1})}
\newcommand{\seqofloat}{\seq{FLOAT}}
\newcommand{\tuple}[1]{\text{tuple of}~(#1)}
\begin{document}

\title{Module Interface Specification for FSL}

\author{Bo Cao}

\date{\today}

\maketitle

\pagenumbering{roman}

\an{The multilined table looks funny when I use makecell to make a cell with multiple lines. I would be thankful if someone could enlighten me with some better ways.}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov. 26, 2019 & 0.99 & First Draft\\
Dec. 10, 2019 & 1.0 & Final version\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \url{https://github.com/caobo1994/FourierSeries/blob/master/docs/SRS/SRS.pdf}.
We also define the following acronyms for the scope of this document
\begin{center}
	
\begin{tabular}{c c}
	\hline
	\textbf{Acronym} & \textbf{Full Text}\\
	\hline
	OOR & Out of range\\
	MC & Mismatched CFS\\
	\hline
\end{tabular}
\end{center}
\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
Fourier Series Library (FSL).

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/caobo1994/FourierSeries/}.

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

For simplicity, the sequence of type \li{T} will be abbreviated as seq(\li{T}),
while that with dimensions $[l_1, ..., l_n]$ as seq(\li{T}, $l_1, ...,
l_n$). Furthermore, we use both \li{Var: Type} and \li{Type Var} to indicate
that variable \li{Var} is of type \li{Type}.

For consistency with mathematical notations, we denote $A: \mathbb{B}$ as $A \in \mathbb{B}$, when $\mathbb{B}$ is the notation of a common mathematical set, and $A$ is a member of $\mathbb{B}$.  

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & Infrastructure (hardware-related part, external)\\
		\midrule
		
		\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} 
		& Data definition module\\
		& Conversion module\\
		& Transformation module\\
		& Basic operations module\\
		& Advanced operations module\\
		\midrule
		
		\multirow{3}{0.3\textwidth}{Software Decision Module} 
		& Linear solver (external or partially external)\\
		& Integral (external or partially external)\\
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS of Infrastructure} \label{MIS:Infra}
\subsection{Module}

Infrastructure.

\subsection{Uses}

None.
\subsection{Syntax}
\subsection{Exported Data Type}
\begin{itemize}
	\item[FLOAT] a floating point data type used in the library.
	\item [sequence] the abstract sequence data type.
\end{itemize}

\section{MIS of Data Definition} \label{MIS:DataDef}
\subsection{Module}

Data Definition.

\subsection{Uses}

Infrastructure.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Data Type}
There is one exported data type, \li{CFST}, which is the type of a CFS
object. (abstract, with one type template \li{FLOAT}, indicating floating point
types)

The structure of \li{CFST} is
\begin{itemize}
	\item $n$: integer
	\item $\omega$: \li{FLOAT}
	\item $A$: seq(\li{FLOAT}, $n$)
	\item $B$: seq(\li{FLOAT}, $n+1$)
\end{itemize}

The mathematical notation is
\begin{equation*}
	\text{CFST}:=\tuple{n:\mathbb{N}, \\\omega:\float,\\ A: \text{TA},\\ B:\text{TB}}
\end{equation*}
where TA and TB are
\begin{equation*}
	\begin{aligned}
	\text{TA}:=&\text{seq}(\li{FLOAT}, n)\\
	\text{TB}:=&\text{seq}(\li{FLOAT}, n+1)\\
	\end{aligned}
\end{equation*}
During implementation, it is recommended that the sequence type used above are random accessible.

\subsubsection{Exported Access Programs}
The exported access programs for this module are mainly getters and setters. For simplicity, we use the following getter and setter rules.

For each variable X, the getters and setters are

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{getX} & & \li{X}: type of X & None.\\\hline
		\li{setX} & \li{X}: type of X & & None. \\\hline
	\end{tabular}
\end{center}

Furthermore, we design getters and setters for each element of $A$ and $B$. For each $X$ being $A$ or $B$, the syntax of the function intended for the element $X_i$ is
\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{getXi} & $i\in \mathbb{N}$& \li{V: FLOAT} & OOR.\\\hline
		\li{setXi} &  $i\in \mathbb{N}$, \li{V: FLOAT} & & OOR. \\\hline
	\end{tabular}
\end{center}
For convenience, we may use \li{A(i)} and \li{B(i)} to represent \li{getAi(i)}
and \li{getBi(i)}, respectively.

Based on the setters, we implement a constructor for \li{CFST}.

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{new CFST} & $n, \omega, A, B$: same type as their namesake in \li{CFST}& \li{CFST CFS}& None.\\\hline
	\end{tabular}
\end{center}
\subsection{Semantics}
\wss{Rather than putting the details as an exported type, you should have state
  variables here to store the state information.  You have behaviour that is
  more involved than simply using a tuple.  There are different types of getters
  and setters, and you have exceptions.  You also need a constructor so you
  create objects of this type.}

\an{I have thought of exported type versus state variables, and I think exported variables for some reason. My understanding is that people use state variables when the program mainly involves the transition of states (members of this type) under given conditions, much like a (finite) state machine. As for exported data type, I tend to think that this is for a set of members (loosely) combined as an set of variables.}

\subsubsection{Assumptions}
\subsubsection{Access Routine Semantics}

We give a template for \li{getX}, \li{setX}, \li{getXi} and \li{setXi} respectively.
\noindent \li{setX(Xin)}:
\begin{itemize}
	\item transition: $X=\textit{Xin}$.
\end{itemize}
\noindent \li{getX()}:
\begin{itemize}
	\item output: $X$.
\end{itemize}
\noindent \li{setXi(i, V)}:
\begin{itemize}
	\item transition: $i>=\textit{offset}\Rightarrow setX[i-\textit{offset}]=V$
	\item exception: $\text{exc}:=((i<0)\vee(i>n)\Rightarrow \text{OOR})$
\end{itemize}
\noindent \li{getXi(i)}:
\begin{itemize}
	\item output: $(i>=\textit{offset}\Rightarrow X[i-\textit{offset}]|\textit{TRUE}\Rightarrow0)$
	\item exception: $\text{exc}:=((i<0)\vee(i>n)\Rightarrow \text{OOR})$
\end{itemize}

In these expressions, $\textit{offset}$ is 0 for \li{X=A} and 1 for \li{X=B}.

\wss{Your shortened notation is fine, but sometimes it is less work for the
  reader if you just expand your definitions.}\an{Elaborated. A lot of stuff is too basic if the reader meets the requirement is the SRS, so I choose not to say that. I guess that I might put too much requirements in the SRS, but I think that users do not know what they want to get, and what they are getting if they do not meet the requirements.}

\noindent\li{new CFST(n, $\omega$, A, B)}
\begin{itemize}
	\item transition: $\textit{CFS}.n:=n,\textit{CFS}.\omega:=\omega,\textit{CFS}.A:=A,\textit{CFS}.B:=B$
	\item output:
	$\textit{CFS}$
\end{itemize}
\section{MIS of Linear Solver}

\subsection{Module}

Linear Solver.

\subsection{Uses}

Infrastructure.

\subsection{Syntax}

\subsubsection{Export Access Programs}

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{LinSolve} &\makecell{\li{m}: $\mathbb{N}$\\A: seq(\li{FLOAT}, \li{m}, \li{m})\\b:  seq(\li{FLOAT}, \li{m})} & x: seq(\li{FLOAT}, \li{m}) &\makecell{Solution non-exist\\Solution not unique}.\\\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{Assumptions}
\subsubsection{Access Routine Semantics}
\noindent \li{LinSolve(m, A, b)}:
\begin{itemize}
	\item output: $x$ that suits $Ax=b$.
	\item exception: $\text{exc}:=(\text{Solution non-exist} \vee \text{Solution not unique}\Rightarrow \text{Cannot return solution})$
\end{itemize} \wss{This
  would be better if you elaborated on it.  Our goal is to be unambiguous.  It
  wouldn't be that much work to specify what a linear solver returns.}\an{Done.}

\section{MIS of Integral}
\subsection{Module}
Integral.
\subsection{Uses}
Infrastructure.
\subsection{Syntax}
\subsubsection{Export Access Programs}

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{Integral} &\makecell{\li{f}: \li{FLOAT}$\rightarrow$\li{FLOAT}\\\li{a}, \li{b}: \li{FLOAT}} & res: \li{FLOAT} &\makecell{Integral non-exist\\or not computable}.\\\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{Access Routine Semantics}

\noindent \li{Integral(f, a, b)}:
\begin{itemize}
	\item output: $\int_{a}^{b}f(t)\text{d} t$
	\item exception: $\text{Integral non-exist}\vee\text{Integral not computable}\Rightarrow\text{Integral not found}$ \wss{The programmer may not know as much as
            you.  This isn't enough information on the possible exceptions.}\an{Done.}
\end{itemize}

\section{MIS of Conversion}
\subsection{Module}
Conversion.
\subsection{Uses}
Data Definition.
\subsection{Syntax}
\subsubsection{Export Access Programs}
\wss{We say $n: \mathbb{N}$}\an{I know, but I am used to this way. I have made a notation about this in Section 4, Notation.}\an{Move comments here from the table, to have table not corrupted by the comments.}
\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\func{ConvertFrom} &\makecell{$n\in \mathbb{N}$\\$\omega$: \li{FLOAT} \\$A$: sequence of \li{FLOAT}\\$B$: sequence of \li{FLOAT}} & \li{CFST CFS} & \makecell{\li{OOR}: $\omega\leq0$\\\li{MC}: Mismatch between \\$n$, (size of $A$ -1),\\ and size of $B$}
		\func{ConvertTo} &\makecell{\li{CFST CFS}}&Same as inputs of \li{ConvertFrom} & None
		\\\hline 
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsection{Access Routine Semantics}
\noindent \li{ConvertFrom($n, \omega, A, B$)}: 
\begin{itemize}
	\item output: $\textit{new CFST}(n, \omega, A, B)$ \wss{You want to call your
            constructor here}\an{Reorganized, forgot to implement a constructor. Guess I have written C for quite sometime.}
	\item exception: $
	\text{exc}:=(\omega\leq0 \Rightarrow \text{OOR}||A| \neq n+1 \Rightarrow \text{MC} | |B| \neq n \Rightarrow \text{MC})
	$
\end{itemize}

\noindent \li{ConvertFrom(CFS)}: 
\begin{itemize}
	\item output: $n:=\textit{CFS}.n, \omega:=\textit{CFS}.\omega, A:=\textit{CFS}.A, B:=\textit{CFS}.B$
\end{itemize}
  \wss{You might find that others do not find all of your steps as
  straightfoward as you do.}\an{Done here.}

\section{MIS for Transformation}
\subsection{Module}
Transformation.
\subsection{Uses}
Data Definition, Integration.
\subsection{Syntax}
\subsubsection{Export Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\func{TransformTo} & \makecell{$f\in \{\mathbb{R}\rightarrow\mathbb{R}\}$\\$n\in\mathbb{N}$\\$\omega\in\mathbb{R}^{+}$} &\li{CFST CFS}& None.
		\func{FunctionValue} & \makecell{\li{CFST CFS}\\$t\in\mathbb{R}$} & $V\in \mathbb{R}$&None.
		\\\hline 
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsection{Access Program Semantics}
\noindent \li{TransformTo}($f, n, \omega$):
\begin{itemize}
	\item output:
	\begin{align*} A_0:=&(1/2\pi)\int_{-\pi}^{\pi}f(t)\text{d}t,\\ A_i:=&(1/\pi)\int_{-\pi}^{\pi}f(t)\cos(i\omega t)\text{d}t,\\ B_i:=&(1/2\pi)\int_{-\pi}^{\pi}f(t)\sin(i\omega t)\text{d}t\\
	A:=&<A_0, ..., A_n>,\\
	B:=&<B_1, ..., B_n>, \\
	\text{CFS}.n, \text{CFS}.\omega, \text{CFS}.A, \text{CFS}.B :=& n, \omega, A, B\\
	\end{align*}  
\end{itemize}
\noindent \li{FunctionValue}($\text{CFS}, t$):
\begin{itemize}
	\item output: $V:=\sum_{i=0}^{\text{CFS}.n}\text{CFS}.\text{getAi}(i)\cos(i\omega t)+\sum_{i=1}^{\text{CFS}.n}\text{CFS}.\text{getBi}(i)\sin(i\omega t)$  
\end{itemize}
\section{MIS of Basic Operation}
\subsection{Module}
Basic Operations.
\subsection{Uses}
Data Definition, Linear Solver
\subsection{Syntax}
\subsubsection{Export Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\func{CFSMatch} & \li{CFST CFS1, CFST CFS2} & \li{Bool res} & None.
		\func{Addition} & \li{CFST CFS1, CFST CFS2} & \li{CFST CFSres}  & MC
		\func{Subtraction} & \li{CFST CFS1, CFST CFS2} & \li{CFST CFSres} & MC
		\func{Multplication} & \li{CFST CFS1, CFST CFS2} & \li{CFST CFSres} & MC
		\func{Divison} & \li{CFST CFS1, CFST CFS2} & \li{CFST CFSres} & MC
		\func{Amplitude}&\li{CFST CFS1}&\li{FLOAT amp}& None.
		\\\hline 
	\end{tabular}
\end{center}
\subsection{Semantics}
\subsubsection{Access Program Semantics}
\noindent \li{CFSMatch(CFST CFS1, CFST CFS2)}:
\begin{itemize} 
	\item output: $(\text{CFS1}.n=\text{CFS2}.n)\wedge(\text{CFS1}.\omega=\text{CFS2}.\omega)\Rightarrow\text{TRUE}|\text{TRUE}\Rightarrow\text{FALSE}$ 
\end{itemize}

The semantics of \li{Addition}, \li{Subtraction}, and \li{Multiplication} are
similar in structure, and the only difference is the calculation of the $A$ and
$B$ variables shown below, which is consistent with the corresponding theories
introduced in SRS. That is, the implementer shall choose $A$ and $B $ in IM4 of SRS for \li{Subtraction}, IM5 for \li{Multiplication}, IM6 for \li{Division}. \wss{It is a good idea to reference the SRS.  It would be
  better if your reference were specific to models (chunks) in the SRS.  The
  less work the reader has to do the better.  You want the translation from MIS
  to code to be almost mechanical.  You also want it to be possible for someone
  that is less knowledgeable than you on the topic of your software.  Ideally, a
  second year student in CS or SE should be able to implement your modules.}\an{Added here accordingly. BTW, I never hope that a second year student in CS/SE of McMaster can implement this module. I know that their mathematics skill sucks, far, far away from implementing this module.}

As an example, we give the semantics of the \li{Addition} function.

\noindent \li{Addition(CFST CFS1, CFST CFS2)}:
\begin{itemize}
	\item output: $A_i:=\text{CFS1}.\text{getAi}(i)+\text{CFS2}.\text{getAi}(i)$,
	$B_i:=\text{CFS1}.\text{getBi}(i)+\text{CFS2}.\text{getBi}(i)$,\\
	$A:=<A_0, ..., A_{\text{CFS1.n}}>$, $B:=<B_0, ..., B_{\text{CFS1.n}}>$,\\
	$\text{CFSres}.n, \text{CFSres}.\omega, \text{CFSres}.A, \text{CFSres}.B:=\text{CFS1}.n, \text{CFS1}.\omega, A, B$
	\item exception: $\text{exc}:=(\text{CFSMatch}(\text{CFS1}, \text{CFS2})=\text{FALSE}\Rightarrow\text{MC})$
\end{itemize}

As for \li{Division}, the difference is much significant. The $A$ and $B$ is computed as follows
\begin{align*}
	x:=&\text{LinSolve}(2n+1, M, y),\\
	A:=&x[0,\text{CFS1}.n+1],\\
	B:=&x[\text{CFS1}.n+1, |x|]
\end{align*}
where $M$ and $y$ are constructed in accordance with the theories for division in SRS.

\noindent \li{Amplitude(CFST CFS1)}:
\begin{itemize} 
	\item output: $amp:=\sqrt{\text{CFS1}.\text{getAi}(0)^2+(1/2)*\sum_{i=1}^{\text{CFS1}.n}(\text{CFS1}.\text{getAi}(i)^2+\text{CFS1}.\text{getBi}(i)^2)}$ 
\end{itemize}

\section{MIS for Advanced Operation}
\subsection{Module}
Advanced Operation.
\subsection{Uses}
Basic Operation.
\subsection{Syntax}
In the following section, \li{TST} is a function type $\mathbb{Z}^{*}\rightarrow\text{FLOAT}$, and for any object \li{TS} of this type associated with a mathematical function, \li{TS(i)} gives the \li{i}-th Taylor coefficient of this mathematical function.
\subsubsection{Export Access Programs}
\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}
\func{ToleratedEquality} & \li{CFST CFS1, CFST CFS2, FLOAT tol} & \li{Bool res} & MC
\func{Power}&\li{CFST CFS}, $m\in Z^{*}$& \li{CFST CFSres} & None.
\func{Function}&\li{CFST CFS, TST TS} &\li{CFST CFSres}& None.
\\\hline 

\end{tabular}
\end{center}

\subsection{Semantics}


\subsubsection{Access Routine Semantics}

\noindent \li{ToleratedEquality(CFST CFS1, CFST CFS2, FLOAT tol)}:
\begin{itemize}
\item output: $\text{res}:=(\text{Amplitude}(\text{Subtraction}(\text{CFS1}, \text{CFS2}))\le \text{tol}\Rightarrow \text{TRUE}|\text{TRUE}\Rightarrow\text{FALSE})$ 
\item exception: $\text{exc}:=(\text{CFSMatch}(\text{CFS1}, \text{CFS2})=\text{FALSE}\Rightarrow\text{MC})$ 
\end{itemize}

\noindent \li{Power(CFST CFS}, $m\in Z^{*}$\li{)}:
\begin{itemize}
	\item output: 
	\begin{gather*}
	A:=<1, 0, ..., 0>, |A|=(n+1);\\ 
	B:=<0, 0, ..., 0>, |B|=n\\
	\text{CFSzero}.n, \text{CFSzero}.\omega, \text{CFSzero}.A, \text{CFSzero}.B:=n, \omega, A, B\\
	\text{CFSres}:=(m=0\Rightarrow \text{CFSzero}|\text{TRUE}\Rightarrow \text{Multiplication}(\text{CFS}, \text{Power}(\text{CFS}, m-1)))
	\end{gather*}
\end{itemize}

\noindent \li{Function(CFST CFS, TST TS)}:
\begin{itemize}
	\item output: $\text{CFSres}:=\sum_{i=0}^{\text{CFS}.n}(1/i!)\text{TS}(i)\text{Power}(\text{CFS}, i)$
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\appendix

\wss{Extra information if required}
\an{Content added here. I expect to add some guidelines for implementations, but I forgot to mention here, since at the time of first draft, I did not consider about implementation too much.}
\section{Guild Line for Implementing in C++}\label{Appendix:guildeline}
This module can be implemented in C++ by doing a direct translation from mathematics notation to C++.
The following translation rules are recommended and expected to be followed.
\begin{itemize}
	\item All the newly defined types and functions shall be in \licpp{namespace FSL}.
	\item \li{seq(A)} and \li{seq(A, m)} shall be implemented as \licpp{std::vector<A>}, while \li{seq(A, m, n)} shall be implemented as \licpp{std::vector<std::vector<A>>}. The size of each \licpp{std::vector} shall be checked manually, and exceptions shall be thrown if needed.
	\item Type $\mathbb{N}$ shall be implemented as \licpp{size_t}. This type is available after \licpp{#include <vector>;}. 
	\item Type $\mathbb{R}$ shall be implemented as \licpp{FLOAT}, while type $\mathbb{R}\rightarrow\mathbb{R}$ shall be implemented as \licpp{std::function<FLOAT(FLOAT)>}. 
\end{itemize}
\end{document}