\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}
\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{makecell}
\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}
\input{../../Common}
\input{../../Comments}
\newcommand{\func}[1]{\\\hline\li{#1}}
\newcommand{\float}{\text{FLOAT}}
\newcommand{\seq}[2]{seq(\li{#1}, $#2$)}
\newcommand{\seqo}[1]{seq(\li{#1})}
\newcommand{\seqofloat}{\seq{FLOAT}}
\newcommand{\tuple}[1]{\text{tuple of}~(#1)}
\begin{document}

\title{Module Interface Specification for FSL}

\author{Bo Cao}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov. 26, 2019 & 0.99 & First Draft\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \url{https://github.com/caobo1994/FourierSeries/blob/master/docs/SRS/SRS.pdf}.
We also define the following acronyms for the scope of this document
\begin{center}
	
\begin{tabular}{c c}
	\hline
	\textbf{Acronym} & \textbf{Full Text}\\
	\hline
	OOR & Out of range\\
	\hline
\end{tabular}
\end{center}
\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
Fourier Series Library (FSL).

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/caobo1994/FourierSeries/}.

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.
For simplicity, the sequence of type \li{T} will be abbreviated as seq(\li{T}), while that with dimensions $[l_1, ..., l_n]$ as seq(\li{T}, $l_1, ..., l_n$).
\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & Infrastructure (hardware-related part, external)\\
		\midrule
		
		\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} 
		& Data definition module\\
		& Conversion module\\
		& Transformation module\\
		& Basic operations module\\
		& Advanced operations module\\
		\midrule
		
		\multirow{3}{0.3\textwidth}{Software Decision Module} 
		& Linear solver (external or partially external)\\
		& Integral (external or partially external)\\
		& Infrastructure (software-related part, external)\\
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS of Infrastructure} \label{MIS:Infra}
\subsection{Module}

Infrastructure.

\subsection{Uses}

None.
\subsection{Syntax}
\subsection{Exported Data Type}
\begin{itemize}
	\item[FLOAT] a floating point data type used in the library.
	\item [sequence] the abstract sequence data type.
\end{itemize}

\section{MIS of Data Definition} \label{MIS:DataDef}
\subsection{Module}

Data Definition.

\subsection{Uses}

Infrastructure.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Data Type}
There is one exported data type, \li{CFST}, which is the type of a CFS object. (abstract, with one type template \li{FLOAT}, indicating floating point types)

The structure of \li{CFST} is
\begin{itemize}
	\item $n$: integer
	\item $\omega$: \li{FLOAT}
	\item $A$: seq(\li{FLOAT})
	\item $B$: seq(\li{FLOAT})
\end{itemize}

The mathematical notation is
\begin{equation}
	\text{CFST}:=\tuple{n:\mathbb{N}, \\\omega:\float,\\ A: \text{TA},\\ B:\text{TB}}
\end{equation}
where TA and TB are
\begin{equation}
	\begin{aligned}
	\text{TA}:=&seq(\li{FLOAT}, n)\\
	\text{TB}:=&seq(\li{FLOAT}, n+1)\\
	\end{aligned}
\end{equation}
During implementation, it is recommended that the sequence type used above are random accessible.

\subsubsection{Exported Access Programs}
The exported access programs for this module are mainly getters and setters. For simplicity, we use the following getter and setter rules.

For each variable X, the getters and setters are

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{getX} & & \li{X}: type of X & None.\\\hline
		\li{setX} & \li{X}: type of X & & None. \\\hline
	\end{tabular}
\end{center}

Furthermore, we design getters and setters for each element of $A$ and $B$. For each X being A or B, the syntax is
\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{getXi} & & \li{X}: type of X & OOR.\\\hline
		\li{setXi} & \li{X}: type of X & & OOR. \\\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{Assumptions}
\subsubsection{Access Routine Semantics}

This part follows the most common rules of getters and setters. For simplicity, we do not elaborate on them.

\section{MIS of Linear Solver}

\subsection{Module}

Linear Solver.

\subsection{Uses}

Infrastructure.

\subsection{Syntax}

\subsubsection{Export Access Programs}

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{LinSolve} &\makecell{\li{m}: $\mathbb{N}$\\A: seq(\li{FLOAT}, \li{m}, \li{m})\\b:  seq(\li{FLOAT}, \li{m})} & x: seq(\li{FLOAT}, \li{m}) &\makecell{Solution non-exist\\Solution not unique}.\\\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{Assumptions}
\subsubsection{Access Routine Semantics}
This part follows the most common semantics of linear solvers, and for simplicity, we do not elaborate on it.

\section{MIS of Integral}
\subsection{Module}
Integral.
\subsection{Uses}
Infrastructure.
\subsection{Syntax}
\subsubsection{Export Access Programs}

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{Integral} &\makecell{\li{f}: \li{FLOAT}$\rightarrow$\li{FLOAT}\\\li{a}, \li{b}: \li{FLOAT}} & res: \li{FLOAT} &\makecell{Integral non-exist\\or not computable}.\\\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{Access Routine Semantics}

\noindent \li{Integral(f, a, b)}:
\begin{itemize}
	\item output: $\int_{a}^{b}f(t)\text{d} t$
	\item exception: Evident
\end{itemize}

\section{MIS of Conversion}
\subsection{Module}
Conversion.
\subsection{Uses}
Data Definition.
\subsection{Syntax}
\subsubsection{Export Access Programs}

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\func{ConvertFrom} &\makecell{$n$: integer\\$\omega$: \li{FLOAT}\\$A$: sequence of \li{FLOAT}\\$B$: sequence of \li{FLOAT}} & Constructed CFS & \makecell{Mismatch between $n$, (size of $A$ -1), and size of $B$\\$\omega\leq0$}
		\func{ConvertTo} &\makecell{CFS\\user-acquired space \\for outputs}&Same as inputs of \li{ConvertFrom} & None
		\\\hline 
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsection{Access Routine Semantics}
\noindent \li{ConvertFrom(n, omega, A, B)}:
\begin{itemize}
	\item output: \tuple{\li{n}, \li{omega}, \li{A}, \li{B}}
	\item exception: \begin{equation*}
		\text{exc}:=\(\text{omega}\leq 0\Rightarrow\text{OMEGA_NON_POSI}||A|\neq n+1\Rightarrow\text{MISMATCH_SIZE}||B|\neq n \Rightarrow\text{MISMATCH_SIZE}\)
	\end{equation*}
\end{itemize}











\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
\func{ConvertFrom} &\makecell{$n$: integer\\$\omega$: \li{FLOAT}\\$A$: sequence of \li{FLOAT}\\$B$: sequence of \li{FLOAT}} & Constructed CFS & Mismatch between $n$, (size of $A$ -1), and size of $B$
\func{ConvertTo} &\makecell{CFS\\pointers to the space \\for outputs}&Same as inputs of \li{ConvertFrom} & None
\func{TransformTo} & function $f$, $n$, $\omega$&Constructed CFS&Any exception raised by integral module
\func{FunctionValue} & CFS, $t$ & Value of $f(t)$, where CFS comes from $f$&None.
\func{Addition} & \li{CFST CFS1, CFST CFS2} & \li{CFST, CFSres} \ & mismatch of $n$ and $\omega$
\func{Subtraction} & \li{CFST CFS1, CFST CFS2} & \li{CFST, CFSres} & Same as \li{Addition}
\func{Multplication} & \li{CFST CFS1, CFST CFS2} & \li{CFST, CFSres} & Same as \li{Addition}
\func{Divison} & \li{CFST CFS1, CFST CFS2} & \li{CFST, CFSres} & Same as \li{Addition}, plus any exception raised by linear solver and reclassified in \li{Division}.
\func{ToleratedEquality} & \li{CFST CFS1, CFST CFS2, FLOAT tol} & \li{Bool res} & Same as \li{Addition}
\func{Function}&\li{CFST CFS}, Taylor series type variable &\li{CFST, CFSres}&Insufficient length of Taylor series.
\func{Amplitude}&CFS&\li{FLOAT amp}&None.
\\\hline 
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate} 
\item output: \wss{if appropriate} 
\item exception: \wss{if appropriate} 
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\end{document}