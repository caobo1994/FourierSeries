\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}
\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{makecell}
\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}
\input{../../Common}
\input{../../Comments}
\newcommand{\func}[1]{\\\hline\li{#1}}
\newcommand{\float}{\text{FLOAT}}
\newcommand{\seq}[2]{seq(\li{#1}, $#2$)}
\newcommand{\seqo}[1]{seq(\li{#1})}
\newcommand{\seqofloat}{\seq{FLOAT}}
\newcommand{\tuple}[1]{\text{tuple of}~(#1)}
\begin{document}

\title{Module Interface Specification for FSL}

\author{Bo Cao}

\date{\today}

\maketitle

\pagenumbering{roman}

\an{The multilined table looks funny when I use makecell to make a cell with multiple lines. I would be thankful if someone could enlighten me with some better ways.}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov. 26, 2019 & 0.99 & First Draft\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \url{https://github.com/caobo1994/FourierSeries/blob/master/docs/SRS/SRS.pdf}.
We also define the following acronyms for the scope of this document
\begin{center}
	
\begin{tabular}{c c}
	\hline
	\textbf{Acronym} & \textbf{Full Text}\\
	\hline
	OOR & Out of range\\
	MC & Mismatched CFS\\
	\hline
\end{tabular}
\end{center}
\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
Fourier Series Library (FSL).

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/caobo1994/FourierSeries/}.

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

For simplicity, the sequence of type \li{T} will be abbreviated as seq(\li{T}),
while that with dimensions $[l_1, ..., l_n]$ as seq(\li{T}, $l_1, ...,
l_n$). Furthermore, we use both \li{Var: Type} and \li{Type Var} to indicate
that variable \li{Var} is of type \li{Type}.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & Infrastructure (hardware-related part, external)\\
		\midrule
		
		\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} 
		& Data definition module\\
		& Conversion module\\
		& Transformation module\\
		& Basic operations module\\
		& Advanced operations module\\
		\midrule
		
		\multirow{3}{0.3\textwidth}{Software Decision Module} 
		& Linear solver (external or partially external)\\
		& Integral (external or partially external)\\
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS of Infrastructure} \label{MIS:Infra}
\subsection{Module}

Infrastructure.

\subsection{Uses}

None.
\subsection{Syntax}
\subsection{Exported Data Type}
\begin{itemize}
	\item[FLOAT] a floating point data type used in the library.
	\item [sequence] the abstract sequence data type.
\end{itemize}

\section{MIS of Data Definition} \label{MIS:DataDef}
\subsection{Module}

Data Definition.

\subsection{Uses}

Infrastructure.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Data Type}
There is one exported data type, \li{CFST}, which is the type of a CFS
object. (abstract, with one type template \li{FLOAT}, indicating floating point
types)

The structure of \li{CFST} is
\begin{itemize}
	\item $n$: integer
	\item $\omega$: \li{FLOAT}
	\item $A$: seq(\li{FLOAT}, $n$)
	\item $B$: seq(\li{FLOAT}, $n+1$)
\end{itemize}

The mathematical notation is
\begin{equation*}
	\text{CFST}:=\tuple{n:\mathbb{N}, \\\omega:\float,\\ A: \text{TA},\\ B:\text{TB}}
\end{equation*}
where TA and TB are
\begin{equation*}
	\begin{aligned}
	\text{TA}:=&\text{seq}(\li{FLOAT}, n)\\
	\text{TB}:=&\text{seq}(\li{FLOAT}, n+1)\\
	\end{aligned}
\end{equation*}
During implementation, it is recommended that the sequence type used above are random accessible.

\subsubsection{Exported Access Programs}
The exported access programs for this module are mainly getters and setters. For simplicity, we use the following getter and setter rules.

For each variable X, the getters and setters are

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{getX} & & \li{X}: type of X & None.\\\hline
		\li{setX} & \li{X}: type of X & & None. \\\hline
	\end{tabular}
\end{center}

Furthermore, we design getters and setters for each element of $A$ and $B$. For each $X$ being $A$ or $B$, the syntax of the function intended for the element $X_i$ is
\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{getXi} & $i\in \mathbb{N}$& \li{V: FLOAT} & OOR.\\\hline
		\li{setXi} &  $i\in \mathbb{N}$, \li{V: FLOAT} & & OOR. \\\hline
	\end{tabular}
\end{center}
For convenience, we may use \li{A(i)} and \li{B(i)} to represent \li{getAi(i)}
and \li{getBi(i)}, respectively.

\subsection{Semantics}
\wss{Rather than putting the details as an exported type, you should have state
  variables here to store the state information.  You have behaviour that is
  more involved than simply using a tuple.  There are different types of getters
  and setters, and you have exceptions.  You also need a constructor so you
  create objects of this type.}

\subsubsection{Assumptions}
\subsubsection{Access Routine Semantics}

This part follows the most common rules of getters and setters. For simplicity,
we do not elaborate on them.

Note the exceptions of \li{setXi} and \li{getXi} are 
\begin{equation*}
	\text{exc}:=((i<M)\vee(i>n)\Rightarrow \text{OOR})
\end{equation*}
where $M$ is 0 for \li{X=A} and 1 for \li{X=B}.

\wss{Your shortened notation is fine, but sometimes it is less work for the
  reader if you just expand your definitions.}

\section{MIS of Linear Solver}

\subsection{Module}

Linear Solver.

\subsection{Uses}

Infrastructure.

\subsection{Syntax}

\subsubsection{Export Access Programs}

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{LinSolve} &\makecell{\li{m}: $\mathbb{N}$\\A: seq(\li{FLOAT}, \li{m}, \li{m})\\b:  seq(\li{FLOAT}, \li{m})} & x: seq(\li{FLOAT}, \li{m}) &\makecell{Solution non-exist\\Solution not unique}.\\\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{Assumptions}
\subsubsection{Access Routine Semantics}
This part follows the most common semantics of linear solvers solving the
equation $Ax=b$ for x, and for simplicity, we do not elaborate on it.  \wss{This
  would be better if you elaborated on it.  Our goal is to be unambiguous.  It
  wouldn't be that much work to specify what a linear solver returns.}

\section{MIS of Integral}
\subsection{Module}
Integral.
\subsection{Uses}
Infrastructure.
\subsection{Syntax}
\subsubsection{Export Access Programs}

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{Integral} &\makecell{\li{f}: \li{FLOAT}$\rightarrow$\li{FLOAT}\\\li{a}, \li{b}: \li{FLOAT}} & res: \li{FLOAT} &\makecell{Integral non-exist\\or not computable}.\\\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{Access Routine Semantics}

\noindent \li{Integral(f, a, b)}:
\begin{itemize}
	\item output: $\int_{a}^{b}f(t)\text{d} t$
	\item exception: Evident \wss{The programmer may not know as much as
            you.  This isn't enough information on the possible exceptions.}
\end{itemize}

\section{MIS of Conversion}
\subsection{Module}
Conversion.
\subsection{Uses}
Data Definition.
\subsection{Syntax}
\subsubsection{Export Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\func{ConvertFrom} &\makecell{$n\in \mathbb{N}$ \wss{We say $n: \mathbb{N}$}\\$\omega$: \li{FLOAT} \\$A$: sequence of \li{FLOAT}\\$B$: sequence of \li{FLOAT}} & \li{CFST CFS} & \makecell{\li{OOR}: $\omega\leq0$\\\li{MC}: Mismatch between \\$n$, (size of $A$ -1),\\ and size of $B$}
		\func{ConvertTo} &\makecell{\li{CFST CFS}\\$n, \omega, A, B$: same\\ type as their\\ namesakes in \li{CFST}}&Same as inputs of \li{ConvertFrom} & None
		\\\hline 
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsection{Access Routine Semantics}
\noindent ConvertFrom($n, \omega, A, B$): 
\begin{itemize}
	\item output: $\text{CFS}.n, \text{CFS}.\omega, \text{CFS}.A,
          \text{CFS}.B := n, \omega, A, B$ \wss{You want to call your
            constructor here}
	\item exception: $
	\text{exc}:=(\omega\leq0 \Rightarrow \text{OOR}||A| \neq n+1 \Rightarrow \text{MC} | |B| \neq n \Rightarrow \text{MC})
	$
\end{itemize}

The semantics for \li{ConvertTo} is straightforward, and we do not elaborate on
it.  \wss{You might find that others do not find all of your steps as
  straightfoward as you do.}

\section{MIS for Transformation}
\subsection{Module}
Transformation.
\subsection{Uses}
Data Definition, Integration.
\subsection{Syntax}
\subsubsection{Export Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\func{TransformTo} & \makecell{$f\in \{\mathbb{R}\rightarrow\mathbb{R}\}$\\$n\in\mathbb{N}$\\$\omega\in\mathbb{R}^{+}$} &\li{CFST CFS}& None.
		\func{FunctionValue} & \makecell{\li{CFST CFS}\\$t\in\mathbb{R}$} & $V\in \mathbb{R}$&None.
		\\\hline 
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsection{Access Program Semantics}
\noindent \li{TransformTo}($f, n, \omega$):
\begin{itemize}
	\item output:
	\begin{align*} A_0:=&(1/2\pi)\int_{-\pi}^{\pi}f(t)\text{d}t,\\ A_i:=&(1/\pi)\int_{-\pi}^{\pi}f(t)\cos(i\omega t)\text{d}t,\\ B_i:=&(1/2\pi)\int_{-\pi}^{\pi}f(t)\sin(i\omega t)\text{d}t\\
	A:=&<A_0, ..., A_n>,\\
	B:=&<B_1, ..., B_n>, \\
	\text{CFS}.n, \text{CFS}.\omega, \text{CFS}.A, \text{CFS}.B :=& n, \omega, A, B\\
	\end{align*}  
\end{itemize}
\noindent \li{FunctionValue}($\text{CFS}, t$):
\begin{itemize}
	\item output: $V:=\sum_{i=0}^{\text{CFS}.n}\text{CFS}.\text{getAi}(i)\cos(i\omega t)+\sum_{i=1}^{\text{CFS}.n}\text{CFS}.\text{getBi}(i)\sin(i\omega t)$  
\end{itemize}
\section{MIS of Basic Operation}
\subsection{Module}
Basic Operations.
\subsection{Uses}
Data Definition, Linear Solver
\subsection{Syntax}
\subsubsection{Export Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\func{CFSMatch} & \li{CFST CFS1, CFST CFS2} & \li{Bool res} & None.
		\func{Addition} & \li{CFST CFS1, CFST CFS2} & \li{CFST CFSres}  & MC
		\func{Subtraction} & \li{CFST CFS1, CFST CFS2} & \li{CFST CFSres} & MC
		\func{Multplication} & \li{CFST CFS1, CFST CFS2} & \li{CFST CFSres} & MC
		\func{Divison} & \li{CFST CFS1, CFST CFS2} & \li{CFST CFSres} & MC
		\func{Amplitude}&\li{CFST CFS1}&\li{FLOAT amp}& None.
		\\\hline 
	\end{tabular}
\end{center}
\subsection{Semantics}
\subsubsection{Access Program Semantics}
\noindent \li{CFSMatch(CFST CFS1, CFST CFS2)}:
\begin{itemize} 
	\item output: $(\text{CFS1}.n=\text{CFS2}.n)\wedge(\text{CFS1}.\omega=\text{CFS2}.\omega)\Rightarrow\text{TRUE}|\text{TRUE}\Rightarrow\text{FALSE}$ 
\end{itemize}

The semantics of \li{Addition}, \li{Subtraction}, and \li{Multiplication} are
similar in structure, and the only difference is the calculation of the $A$ and
$B$ variables shown below, which is consistent with the corresponding theories
introduced in SRS.  \wss{It is a good idea to reference the SRS.  It would be
  better if your reference were specific to models (chunks) in the SRS.  The
  less work the reader has to do the better.  You want the translation from MIS
  to code to be almost mechanical.  You also want it to be possible for someone
  that is less knowledgeable than you on the topic of your software.  Ideally, a
  second year student in CS or SE should be able to implement your modules.}

As an example, we give the semantics of the \li{Addition} function.

\noindent \li{Addition(CFST CFS1, CFST CFS2)}:
\begin{itemize}
	\item output: $A_i:=\text{CFS1}.\text{getAi}(i)+\text{CFS2}.\text{getAi}(i)$,
	$B_i:=\text{CFS1}.\text{getBi}(i)+\text{CFS2}.\text{getBi}(i)$,\\
	$A:=<A_0, ..., A_{\text{CFS1.n}}>$, $B:=<B_0, ..., B_{\text{CFS1.n}}>$,\\
	$\text{CFSres}.n, \text{CFSres}.\omega, \text{CFSres}.A, \text{CFSres}.B:=\text{CFS1}.n, \text{CFS1}.\omega, A, B$
	\item exception: $\text{exc}:=(\text{CFSMatch}(\text{CFS1}, \text{CFS2})=\text{FALSE}\Rightarrow\text{MC})$
\end{itemize}

As for \li{Division}, the difference is much significant. The $A$ and $B$ is computed as follows
\begin{align*}
	x:=&\text{LinSolve}(2n+1, M, y),\\
	A:=&x[0,\text{CFS1}.n+1],\\
	B:=&x[\text{CFS1}.n+1, |x|]
\end{align*}
where $M$ and $y$ are constructed in accordance with the theories for division in SRS.

\noindent \li{Amplitude(CFST CFS1)}:
\begin{itemize} 
	\item output: $amp:=\sqrt{\text{CFS1}.\text{getAi}(0)^2+(1/2)*\sum_{i=1}^{\text{CFS1}.n}(\text{CFS1}.\text{getAi}(i)^2+\text{CFS1}.\text{getBi}(i)^2)}$ 
\end{itemize}

\section{MIS for Advanced Operation}
\subsection{Module}
Advanced Operation.
\subsection{Uses}
Basic Operation.
\subsection{Syntax}
In the following section, \li{TST} is a function type $\mathbb{Z}^{*}\rightarrow\text{FLOAT}$, and for any object \li{TS} of this type associated with a mathematical function, \li{TS(i)} gives the \li{i}-th Taylor coefficient of this mathematical function.
\subsubsection{Export Access Programs}
\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}
\func{ToleratedEquality} & \li{CFST CFS1, CFST CFS2, FLOAT tol} & \li{Bool res} & MC
\func{Power}&\li{CFST CFS}, $m\in Z^{*}$& \li{CFST CFSres} & None.
\func{Function}&\li{CFST CFS, TST TS} &\li{CFST CFSres}& None.
\\\hline 

\end{tabular}
\end{center}

\subsection{Semantics}


\subsubsection{Access Routine Semantics}

\noindent \li{ToleratedEquality(CFST CFS1, CFST CFS2, FLOAT tol)}:
\begin{itemize}
\item output: $\text{res}:=(\text{Amplitude}(\text{Subtraction}(\text{CFS1}, \text{CFS2}))\le \text{tol}\Rightarrow \text{TRUE}|\text{TRUE}\Rightarrow\text{FALSE})$ 
\item exception: $\text{exc}:=(\text{CFSMatch}(\text{CFS1}, \text{CFS2})=\text{FALSE}\Rightarrow\text{MC})$ 
\end{itemize}

\noindent \li{Power(CFST CFS}, $m\in Z^{*}$\li{)}:
\begin{itemize}
	\item output: 
	\begin{gather*}
	A:=<1, 0, ..., 0>, |A|=(n+1);\\ 
	B:=<0, 0, ..., 0>, |B|=n\\
	\text{CFSzero}.n, \text{CFSzero}.\omega, \text{CFSzero}.A, \text{CFSzero}.B:=n, \omega, A, B\\
	\text{CFSres}:=(m=0\Rightarrow \text{CFSzero}|\text{TRUE}\Rightarrow \text{Multiplication}(\text{CFS}, \text{Power}(\text{CFS}, m-1)))
	\end{gather*}
\end{itemize}

\noindent \li{Function(CFST CFS, TST TS)}:
\begin{itemize}
	\item output: $\text{CFSres}:=\sum_{i=0}^{\text{CFS}.n}(1/i!)\text{TS}(i)\text{Power}(\text{CFS}, i)$
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\end{document}