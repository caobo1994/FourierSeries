\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}
\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{makecell}
\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}
\input{../../Common}
\input{../../Comments}
\newcommand{\func}[1]{\\\hline\li{#1}}
\newcommand{\float}{\text{FLOAT}}
\newcommand{\seq}[2]{seq(\li{#1}, $#2$)}
\newcommand{\seqo}[1]{seq(\li{#1})}
\newcommand{\seqofloat}{\seq{FLOAT}}
\newcommand{\tuple}[1]{\text{tuple of}~(#1)}
\begin{document}

\title{Module Interface Specification for FSL}

\author{Bo Cao}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov. 26, 2019 & 0.99 & First Draft\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \url{https://github.com/caobo1994/FourierSeries/blob/master/docs/SRS/SRS.pdf}.
We also define the following acronyms for the scope of this document
\begin{center}
	
\begin{tabular}{c c}
	\hline
	\textbf{Acronym} & \textbf{Full Text}\\
	\hline
	OOR & Out of range\\
	\hline
\end{tabular}
\end{center}
\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
Fourier Series Library (FSL).

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/caobo1994/FourierSeries/}.

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.
For simplicity, the sequence of type \li{T} will be abbreviated as seq(\li{T}), while that with dimensions $[l_1, ..., l_n]$ as seq(\li{T}, $l_1, ..., l_n$).
\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & Infrastructure (hardware-related part, external)\\
		\midrule
		
		\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} 
		& Data definition module\\
		& Conversion module\\
		& Transformation module\\
		& Basic operations module\\
		& Advanced operations module\\
		\midrule
		
		\multirow{3}{0.3\textwidth}{Software Decision Module} 
		& Linear solver (external or partially external)\\
		& Integral (external or partially external)\\
		& Infrastructure (software-related part, external)\\
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS of Infrastructure} \label{MIS:Infra}
\subsection{Module}

Infrastructure.

\subsection{Uses}

None.
\subsection{Syntax}
\subsection{Exported Data Type}
\begin{itemize}
	\item[FLOAT] a floating point data type used in the library.
	\item [sequence] the abstract sequence data type.
\end{itemize}

\section{MIS of Data Definition} \label{MIS:DataDef}
\subsection{Module}

Data Definition.

\subsection{Uses}

Infrastructure.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Data Type}
There is one exported data type, \li{CFST}, which is the type of a CFS object. (abstract, with one type template \li{FLOAT}, indicating floating point types)

The structure of \li{CFST} is
\begin{itemize}
	\item $n$: integer
	\item $\omega$: \li{FLOAT}
	\item $A$: seq(\li{FLOAT})
	\item $B$: seq(\li{FLOAT})
\end{itemize}

The mathematical notation is
\begin{equation}
	\text{CFST}:=\tuple{n:\mathbb{N}, \\\omega:\float,\\ A: \text{TA},\\ B:\text{TB}}
\end{equation}
where TA and TB are
\begin{equation}
	\begin{aligned}
	\text{TA}:=&seq(\li{FLOAT}, n)\\
	\text{TB}:=&seq(\li{FLOAT}, n+1)\\
	\end{aligned}
\end{equation}
During implementation, it is recommended that the sequence type used above are random accessible.

\subsubsection{Exported Access Programs}
The exported access programs for this module are mainly getters and setters. For simplicity, we use the following getter and setter rules.

For each variable X, the getters and setters are

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{getX} & & \li{X}: type of X & None.\\\hline
		\li{setX} & \li{X}: type of X & & None. \\\hline
	\end{tabular}
\end{center}

Furthermore, we design getters and setters for each element of $A$ and $B$. For each X being A or B, the syntax is
\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{getXi} & & \li{X}: type of X & OOR.\\\hline
		\li{setXi} & \li{X}: type of X & & OOR. \\\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{Assumptions}
\subsubsection{Access Routine Semantics}

This part follows the most common rules of getters and setters. For simplicity, we do not elaborate on them.

\section{MIS of Linear Solver}

\subsection{Module}

Linear Solver.

\subsection{Uses}

Infrastructure.

\subsection{Syntax}

\subsubsection{Export Access Programs}

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{LinSolve} &\makecell{\li{m}: $\mathbb{N}$\\A: seq(\li{FLOAT}, \li{m}, \li{m})\\b:  seq(\li{FLOAT}, \li{m})} & x: seq(\li{FLOAT}, \li{m}) &\makecell{Solution non-exist\\Solution not unique}.\\\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{Assumptions}
\subsubsection{Access Routine Semantics}
This part follows the most common semantics of linear solvers, and for simplicity, we do not elaborate on it.

\section{MIS of Integral}
\subsection{Module}
Integral.
\subsection{Uses}
Infrastructure.
\subsection{Syntax}
\subsubsection{Export Access Programs}

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
		\hline
		\li{Integral} &\makecell{\li{f}: \li{FLOAT}$\rightarrow$\li{FLOAT}\\\li{a}, \li{b}: \li{FLOAT}} & res: \li{FLOAT} &\makecell{Integral non-exist\\or not computable}.\\\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{Access Routine Semantics}

\noindent \li{Integral(f, a, b)}:
\begin{itemize}
	\item output: $\int_{a}^{b}f(t)\text{d} t$
	\item exception: Evident
\end{itemize}

\section{MIS of Conversion}
\subsection{Module}
Conversion.
\subsection{Uses}
Data Definition.
\subsection{Syntax}
\subsubsection{Export Access Programs}
With \li{O} being short for \li{OUT\_OF\_BOUNDARY} and \li{M} being short for \li{MISMATCHED\_SIZE}, 
\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\func{ConvertFrom} &\makecell{$n\in \mathbb{N}$\\$\omega$: \li{FLOAT} \\$A$: sequence of \li{FLOAT}\\$B$: sequence of \li{FLOAT}} & \li{CFST CFS} & \makecell{\li{O}: $\omega\leq0$\\\li{M}: Mismatch between \\$n$, (size of $A$ -1),\\ and size of $B$}
		\func{ConvertTo} &\makecell{\li{CFST CFS}\\user-acquired space \\for outputs}&Same as inputs of \li{ConvertFrom} & None
		\\\hline 
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsection{Access Routine Semantics}
\noindent ConvertFrom($n, \omega, A, B$): 
\begin{itemize}
	\item output: $\text{CFS}.n, \text{CFS}.\omega, \text{CFS}.A, \text{CFS}.B := n, \omega, A, B$
	\item exception: $
	\text{exc}:=(\omega\leq0 \Rightarrow O||A| \neq n+1 \Rightarrow M | |B| \neq n \Rightarrow M)
	$
\end{itemize}

The semantics for \li{ConvertTo} is straightforward, and we do not elaborate on it.

\section{MIS for Transformation}
\subsection{Module}
Transformation.
\subsection{Uses}
Data Definition, Integration.
\subsection{Syntax}
\subsubsection{Export Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\func{TransformTo} & \makecell{$f\in \{\mathbb{R}\rightarrow\mathbb{R}\}$\\$n\in\mathbb{N}$\\$\omega\in\mathbb{R}^{+}$} &\li{CFST CFS}& None.
		\func{FunctionValue} & \makecell{\li{CFST CFS}\\$t\in\mathbb{R}$} & $V\in \mathbb{R}$&None.
		\\\hline 
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsection{Access Program Semantics}
\noindent \li{TransformTo}($f, n, \omega$):
\begin{itemize}
	\item output: $\text{CFS}.n, \text{CFS}.\omega, \text{CFS}.A, \text{CFS}.B := n, \omega, A, B$, where $A_i$ and $B_i$ are computed in accordance with T1 of the SRS.  
\end{itemize}
\noindent \li{FunctionValue}($\text{CFS}, t$):
\begin{itemize}
	\item output: $V:=\sum_{i=0}^{\text{CFS}.n}\text{CFS}.A(i)\cos(i\omega t)+\sum_{i=1}^{\text{CFS}.n}\text{CFS}.B(i)\sin(i\omega t)$  
\end{itemize}
\section{MIS of Basic Operation}
\subsection{Module}
Basic Operations.
\subsection{Uses}
Data Definition, Linear Solver
\subsection{Syntax}
\subsubsection{Export Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\func{CFSMatch} & \li{CFST CFS1, CFST CFS2} & \li{Bool res} & None.
		\func{Addition} & \li{CFST CFS1, CFST CFS2} & \li{CFST CFSres}  & mismatch of $n$ and $\omega$
		\func{Subtraction} & \li{CFST CFS1, CFST CFS2} & \li{CFST CFSres} & Same as \li{Addition}
		\func{Multplication} & \li{CFST CFS1, CFST CFS2} & \li{CFST CFSres} & Same as \li{Addition}
		\func{Divison} & \li{CFST CFS1, CFST CFS2} & \li{CFST CFSres} & Same as \li{Addition}, plus any exception raised by linear solver and reclassified in \li{Division}.
		\func{Amplitude}&\li{CFST CFS1}&\li{FLOAT amp}&None.
		\\\hline 
	\end{tabular}
\end{center}
\subsection{Semantics}
\subsubsection{Access Program Semantics}
\noindent \li{CFSMatch(CFST CFS1, CFST CFS2)}:
\begin{itemize} 
	\item output: $(\text{CFS1}.n=\text{CFS2}.n)\wedge(\text{CFS1}.\omega=\text{CFS2}.\omega)\Rightarrow\text{TRUE}|\text{TRUE}\Rightarrow\text{FALSE}$ 
\end{itemize}

The semantics of \li{Addition}, \li{Subtraction}, and \li{Multiplication} are similar in structure, and the only difference is the calculation of the $A$ and $B$ variables shown below, which is consistent with the corresponding theories introduced in SRS.

As an example, we give the semantics of the \li{Addition} function.

\noindent \li{Addition(CFST CFS1, CFST CFS2)}:
\begin{itemize}
	\item output: $A_i:=\text{CFS1}.\text{getAi}(i)+\text{CFS2}.\text{getAi}(i)$,
	$B_i:=\text{CFS1}.\text{getBi}(i)+\text{CFS2}.\text{getBi}(i)$,\\
	$A:=[A_0, ..., A_{\text{CFS1.n}}]$, $B:=[B_0, ..., B_{\text{CFS1.n}}]$,\\
	$\text{CFSres}.n, \text{CFSres}.\omega, \text{CFSres}.A, \text{CFSres}.B:=\text{CFS1}.n, \text{CFS1}.\omega, A, B$
	\item exception: $\text{exc}:=(\text{CFSMatch}(\text{CFS1}, \text{CFS2})=\text{FALSE}\Rightarrow\text{MISMATCH\_CFS})$
\end{itemize}

As for \li{Division}, the difference is much significant. The $A$ and $B$ is computed as follows
\begin{align*}
	x:=&\text{LinSolve}(M, y),\\
	A:=&x[0,\text{CFS1}.n],\\
	B:=&x[\text{CFS1}.n+1, |x|-1]
\end{align*}
where $M$ and $y$ are constructed in accordance with the theories for division in SRS.

\noindent \li{Amplitude(CFS CFS1)}:
\begin{itemize} 
	\item output: $amp:=\sqrt{\text{CFS1}.\text{getAi}(0)^2+(1/2)*\sum_{i=1}^{\text{CFS1}.n}(\text{CFS1}.\text{getAi}(i)^2+\text{CFS1}.\text{getBi}(i)^2)}$ 
\end{itemize}

\section{MIS for Advanced Operation}
\subsection{Module}
Advanced Operation.
\subsection{Uses}
Basic Operation.
\subsection{Syntax}
In the following section, \li{TST} is a function type $\mathbb{Z}^{*}\rightarrow\text{FLOAT}$, and for any object \li{TS} of this type associated with a mathematical function, \li{TS(i)} gives the \li{i}-th Taylor coefficient of this mathematical function.
\subsubsection{Export Access Programs}
\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}
\func{ToleratedEquality} & \li{CFST CFS1, CFST CFS2, FLOAT tol} & \li{Bool res} & Same as \li{Addition}
\func{Power}&\li{CFST CFS}, $m\in Z^{*}$& \li{CFS CFSres} & None
\func{Function}&\li{CFST CFS, TST TS} &\li{CFST, CFSres}&None.
\\\hline 

\end{tabular}
\end{center}

\subsection{Semantics}


\subsubsection{Access Routine Semantics}

\noindent \li{ToleratedEquality(CFST CFS1, CFST CFS2, FLOAT tol)}:
\begin{itemize}
\item output: $res:=(\text{Amplitude}(\text{Subtraction}(CFS1, CFS2))\le tol\Rightarrow \text{TRUE}|\text{TRUE}\Rightarrow\text{FALSE})$ 
\item exception: $\text{exc}:=(\text{CFSMatch}(\text{CFS1}, \text{CFS2})=\text{FALSE}\Rightarrow\text{MISMATCH\_CFS})$ 
\end{itemize}

\noindent \li{Power(CFST CFS}, $m\in Z^{*}$\li{)}:
\begin{itemize}
	\item output: $A:=<1, 0, ..., 0>$, $|A|=(n+1)$; $B:=<0, 0, ..., 0]$, $|B|=n$\\
	$\text{CFSzero}.n, \text{CFSzero}.\omega, \text{CFSzero}.A, \text{CFSzero}.B=n, \omega, A, B$
	$\text{CFSres}:=(m=0\Rightarrow \text{CFSzero}|\text{TRUE}\Rightarrow \text{Multiplication}(\text{CFS}, \text{Power}(\text{CFS}, m-1)))$	
\end{itemize}

\noindent \li{Function(CFST CFS, TST TS)}:
\begin{itemize}
	\item output: $\text{CFSres}:=\sum_{i=0}^{\text{CFS}.n}(1/i!)\text{TS}(i)\text{Power}(\text{CFS}, i)$
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\end{document}